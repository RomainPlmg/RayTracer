#version 460 core

// Define a workers group (8x8 threads)
layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

// Output texture
layout(rgba32f, binding = 0) writeonly uniform image2D imgOutput;

// Uniforms
uniform mat4 u_InverseProjection;
uniform mat4 u_InverseView;
uniform vec3 u_CameraPosition;

struct Ray {
    vec3 origin;
    vec3 direction;
};

struct Sphere {
    vec3 center;
    float radius;
    vec4 color;
};

struct HitPayload {
    float distance;
    vec3 point;
    vec3 normal;
    vec4 color;
};

float hitSphere(Ray ray, Sphere sphere) {
    /**************************************/
    /* Check intersection with the sphere */
    /**************************************/
    /* 
       Ray equation -> P(t) = O + tD (O - origin, D - direction, t - distance from the ray origin to the sphere)
       Sphere equation -> All points P at the exact same distance R from the center C
       So ||P-C|| = R (Vector norm) 

       We want to find t:
       ||P-C|| = R
       <=> (P-C).(P-C) = R²
       <=> R² = P.P - 2P.C + C.C
       <=> R² = (O + tD).(O + tD) - 2(O + tD).C + C.C
       <=> R² = O.O + 2t(O.D) + t²(D.D) - 2(O.C) - 2t(D.C) + C.C
       <=> R² = t²(D.D) + 2t(O.D - D.C) + O.O + C.C - 2(O.C)
       <=> R² = t²(D.D) + 2t(O.D - D.C) + O.O + C.C - 2(O.C)
       <=> t²(D.D) + 2t(D.(O-C)) + ((O-C).(O-C) - R²) = 0

       Let L = O-C -> Vector from the ray origin to the sphere center
       t²(D.D) + 2t(D.L) + (L.L - R²) = 0

       Final equation is at² + tb + c, with:
       a = D.D
       b = 2(D.L)
       c = L.L - R²

       We calculate discriminant to find t
       del = b² - 4ac
       del < 0 -> No solution, the ray is not intersecting the sphere
       del = 0 -> One solution, single intersection point (the ray grazes the sphere)
       del > 0 -> Two solutions, the ray passes through the sphere
    */

    vec3 oc = ray.origin - sphere.center;
    float a = dot(ray.direction, ray.direction);
    float b = 2 * dot(ray.direction, oc);
    float c = dot(oc, oc) - sphere.radius * sphere.radius;

    float delta = b * b - 4 * a * c;
    if (delta < 0) { // No solution
        return -1;
    } else {
        float t = (-b - sqrt(delta)) / 2 * a;
        if (t < 0) return -1; // The sphere is behind us
        return t;
    }
}

HitPayload traceRay(Ray ray) {
    HitPayload payload;

    // Build a sphere
    Sphere spheres[2];
    spheres[0].center = vec3(0.0, 0.0, -5.0);
    spheres[0].radius = 1.0;
    spheres[0].color = vec4(1.0, 0.2, 0.2, 1.0);

    spheres[1].center = vec3(0.0, -101.0, -5.0);
    spheres[1].radius = 100.0;
    spheres[1].color = vec4(0.8, 0.8, 0.8, 1.0);
    
    float closestT = 1e30; // Infinite

    for (int i = 0; i < 2; i++) {
        float t = hitSphere(ray, spheres[i]);
        if (t > 0 && t < closestT) { // Object is closer than the old one
            payload.distance = t;
            payload.point = ray.origin + t * ray.direction;
            payload.normal = normalize(payload.point - spheres[i].center);
            payload.color = spheres[i].color;

            closestT = t;
        }
    }

    return payload;
}

void main() {
    ivec2 pixelCoords = ivec2(gl_GlobalInvocationID.xy);
    vec2 size = imageSize(imgOutput);
    vec2 uv = (vec2(pixelCoords) / size) * 2.0 - 1.0; // Normalize pixel coordinates between -1 & 1
    vec4 target = u_InverseProjection * vec4(uv.x, uv.y, 1.0, 1.0); // Convert from screen coordinates to view coordinates

    Ray ray;
    ray.origin = u_CameraPosition;
    // Convert from view coordinates to world coordinates (If you turn your head)
    // Normalize the vector here because doesn't care about the strength, just want the direction
    ray.direction = vec3(u_InverseView * vec4(normalize(vec3(target) / target.w), 0.0));

    HitPayload payload = traceRay(ray);
    vec3 finalColor;

    if (payload.distance > 0) { // Hit sphere
        vec3 lightDir = normalize(vec3(-1.0, 1.0, -1.0)); // Light direction of the sun
        float diffuse = max(dot(lightDir, payload.normal), 0.0);
        finalColor = payload.color.rgb * diffuse;
    } else {
        finalColor = vec3(0.1, 0.1, 0.2);
    }
    

    imageStore(imgOutput, pixelCoords, vec4(finalColor, 1.0));
}