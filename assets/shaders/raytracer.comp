#version 460 core

struct Material {
    vec4 color;
    float roughness;
    float _pad0[3];
};
struct Sphere {
    vec3 center;
    float _pad0;
    float radius;
    float _pad1[3];
    Material material;
};
struct Ray {
    vec3 origin;
    vec3 direction;
};
struct HitInfo {
    float distance;
    vec3 point;
    vec3 normal;
    vec4 color;
};

// Define a workers group (8x8 threads)
layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

layout(std430, binding = 0) buffer SceneData {
    Sphere spheres[];
};

// Output texture
layout(rgba32f, binding = 0) writeonly uniform image2D imgOutput;

// Uniforms
uniform mat4 u_InverseProjection;
uniform mat4 u_InverseView;
uniform vec3 u_CameraPosition;
uniform float u_Bounces;
uniform int u_SphereCount;

float epsilon = 0.001;
float ambient = 0.1;

float hitSphere(Ray ray, Sphere sphere) {
    /**************************************/
    /* Check intersection with the sphere */
    /**************************************/
    /* 
       Ray equation -> P(t) = O + tD (O - origin, D - direction, t - distance from the ray origin to the sphere)
       Sphere equation -> All points P at the exact same distance R from the center C
       So ||P-C|| = R (Vector norm) 

       We want to find t:
       ||P-C|| = R
       <=> (P-C).(P-C) = R²
       <=> R² = P.P - 2P.C + C.C
       <=> R² = (O + tD).(O + tD) - 2(O + tD).C + C.C
       <=> R² = O.O + 2t(O.D) + t²(D.D) - 2(O.C) - 2t(D.C) + C.C
       <=> R² = t²(D.D) + 2t(O.D - D.C) + O.O + C.C - 2(O.C)
       <=> R² = t²(D.D) + 2t(O.D - D.C) + O.O + C.C - 2(O.C)
       <=> t²(D.D) + 2t(D.(O-C)) + ((O-C).(O-C) - R²) = 0

       Let L = O-C -> Vector from the ray origin to the sphere center
       t²(D.D) + 2t(D.L) + (L.L - R²) = 0

       Final equation is at² + tb + c, with:
       a = D.D
       b = 2(D.L)
       c = L.L - R²

       We calculate discriminant to find t
       del = b² - 4ac
       del < 0 -> No solution, the ray is not intersecting the sphere
       del = 0 -> One solution, single intersection point (the ray grazes the sphere)
       del > 0 -> Two solutions, the ray passes through the sphere
    */

    vec3 oc = ray.origin - sphere.center;
    float a = dot(ray.direction, ray.direction);
    float b = 2 * dot(ray.direction, oc);
    float c = dot(oc, oc) - sphere.radius * sphere.radius;

    float delta = b * b - 4 * a * c;
    if (delta < 0) { // No solution
        return -1;
    } else {
        float t = (-b - sqrt(delta)) / 2 * a;
        if (t < 0) return -1; // The sphere is behind us
        return t;
    }
}

HitInfo traceRay(Ray ray) {
    HitInfo info;
    info.distance = -1.0;
    
    float closestT = 1e30; // Infinite

    for (int i = 0; i < u_SphereCount; i++) {
        float t = hitSphere(ray, spheres[i]);
        if (t > 0 && t < closestT) { // Object is closer than the old one
            info.distance = t;
            info.point = ray.origin + t * ray.direction;
            info.normal = normalize(info.point - spheres[i].center);
            info.color = spheres[i].material.color;

            closestT = t;
        }
    }

    return info;
}

void main() {
    ivec2 pixelCoords = ivec2(gl_GlobalInvocationID.xy);
    vec2 size = imageSize(imgOutput);
    vec2 uv = (vec2(pixelCoords) / size) * 2.0 - 1.0; // Normalize pixel coordinates between -1 & 1
    vec4 target = u_InverseProjection * vec4(uv.x, uv.y, 1.0, 1.0); // Convert from screen coordinates to view coordinates

    Ray ray;
    ray.origin = u_CameraPosition;
    // Convert from view coordinates to world coordinates (If you turn your head)
    // Normalize the vector here because doesn't care about the strength, just want the direction
    ray.direction = vec3(u_InverseView * vec4(normalize(vec3(target) / target.w), 0.0));

    vec3 finalColor;
    HitInfo info = traceRay(ray);

    if (info.distance > 0) { // Hit sphere
        vec3 lightDir = normalize(vec3(1.0, 1.0, 1.0)); // Light direction of the sun
        float diffuse = max(dot(lightDir, info.normal), 0.0);

        // Calculate shadows
        Ray shadowRay = Ray(info.point + info.normal * epsilon, lightDir);
        HitInfo shadowInfo = traceRay(shadowRay);
        if (shadowInfo.distance > 0) {
            finalColor = info.color.rgb * ambient;
        } else {
            finalColor = info.color.rgb * (diffuse + ambient);
        }
    } else {
        finalColor = vec3(0.0);
    }
    

    imageStore(imgOutput, pixelCoords, vec4(finalColor, 1.0));
}