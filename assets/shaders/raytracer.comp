#version 460 core

#define PI 3.1415926535897932384626433832795

struct Material {
    vec3 colour;
    float roughness;
    vec3 emissionColour;
    float emissionStrength;
};
struct Sphere {
    vec3 center;
    float radius;
    Material material;
};
struct Ray {
    vec3 origin;
    vec3 direction;
};
struct HitInfo {
    bool didHit;
    float hitDistance;
    vec3 hitPoint;
    vec3 hitNormal;
    Material hitMaterial;
};

// Define a workers group (8x8 threads)
layout(local_size_x = 32, local_size_y = 32, local_size_z = 1) in;

layout(std430, binding = 0) buffer SceneData {
    Sphere spheres[];
};

// Output texture
layout(rgba32f, binding = 0) writeonly uniform image2D newImgOutput;
layout(rgba32f, binding = 1) uniform image2D oldImgOutput;

// Uniforms
uniform mat4 u_InverseProjection;
uniform mat4 u_InverseView;
uniform vec3 u_CameraPosition;
uniform vec3 u_CameraRight;
uniform vec3 u_CameraUp;
uniform float u_Bounces;
uniform int u_SphereCount;
uniform uint u_FrameIndex;
uniform uint u_NbRaysPerPixel;
uniform float u_DivergeStrength;
uniform float u_Aperture;
uniform float u_FocusDistance;

float epsilon = 0.001;

uint NextRandom(inout uint state) {
    state = state * 747796405u + 2891336453u;
    uint word = ((state >> ((state >> 28u) + 4u)) ^ state) * 277803737u;
    return (word >> 22u) ^ word;
}

// Return a value between 0 & 1;
float RandomFloat(inout uint state) {
    return float(NextRandom(state)) / 4294967295.0;
}

float HitSphere(Ray ray, Sphere sphere) {
    /**************************************/
    /* Check intersection with the sphere */
    /**************************************/
    /* 
       Ray equation -> P(t) = O + tD (O - origin, D - direction, t - distance from the ray origin to the sphere)
       Sphere equation -> All points P at the exact same distance R from the center C
       So ||P-C|| = R (Vector norm) 

       We want to find t:
       ||P-C|| = R
       <=> (P-C).(P-C) = R²
       <=> R² = P.P - 2P.C + C.C
       <=> R² = (O + tD).(O + tD) - 2(O + tD).C + C.C
       <=> R² = O.O + 2t(O.D) + t²(D.D) - 2(O.C) - 2t(D.C) + C.C
       <=> R² = t²(D.D) + 2t(O.D - D.C) + O.O + C.C - 2(O.C)
       <=> R² = t²(D.D) + 2t(O.D - D.C) + O.O + C.C - 2(O.C)
       <=> t²(D.D) + 2t(D.(O-C)) + ((O-C).(O-C) - R²) = 0

       Let L = O-C -> Vector from the ray origin to the sphere center
       t²(D.D) + 2t(D.L) + (L.L - R²) = 0

       Final equation is at² + tb + c, with:
       a = D.D
       b = 2(D.L)
       c = L.L - R²

       We calculate discriminant to find t
       del = b² - 4ac
       del < 0 -> No solution, the ray is not intersecting the sphere
       del = 0 -> One solution, single intersection point (the ray grazes the sphere)
       del > 0 -> Two solutions, the ray passes through the sphere
    */

    vec3 oc = ray.origin - sphere.center;
    float a = dot(ray.direction, ray.direction);
    float b = 2 * dot(ray.direction, oc);
    float c = dot(oc, oc) - sphere.radius * sphere.radius;

    float delta = b * b - 4 * a * c;
    if (delta < 0) { // No solution
        return -1;
    } else {
        float t = (-b - sqrt(delta)) / 2 * a;
        if (t < 0) return -1; // The sphere is behind us
        return t;
    }
}

HitInfo CalculateRayCollision(Ray ray) {
    HitInfo hitInfo;
    hitInfo.hitDistance = -1.0;
    hitInfo.didHit = false;
    
    float closestT = 1e30; // Infinite

    for (int i = 0; i < u_SphereCount; i++) {
        float t = HitSphere(ray, spheres[i]);
        if (t > 0 && t < closestT) { // Object is closer than the old one
            hitInfo.hitDistance = t;
            hitInfo.hitPoint = ray.origin + t * ray.direction;
            hitInfo.hitNormal = normalize(hitInfo.hitPoint - spheres[i].center);
            hitInfo.hitMaterial = spheres[i].material;

            closestT = t;
        }
    }

    if (hitInfo.hitDistance > 0) {
        hitInfo.didHit = true;
    }

    return hitInfo;
}

vec3 RandomDirection(inout uint seed) {
    for (int limit = 0; limit < 100; limit++) {
        // Generate random direction in a cube -1 <-> 1
        vec3 rndVector = vec3 (
            RandomFloat(seed) * 2.0 - 1,
            RandomFloat(seed) * 2.0 - 1,
            RandomFloat(seed) * 2.0 - 1
        );

        // This method generate a cube, then the edges are denser in points, so need to filter
        // If the vector is in the sphere
        if (dot(rndVector, rndVector) < 1.0) {
            return normalize(rndVector);
        }
    }

    return vec3(0.0);
}

vec3 RandomHemisphereDirection(vec3 normal, inout uint seed) {
    vec3 rndDir = RandomDirection(seed);
    return rndDir * sign(dot(normal, rndDir));
}

vec2 RandomPointInCircle(inout uint seed) {
    float angle = RandomFloat(seed) * 2 * PI;
    vec2 pointOnCircle = vec2(cos(angle), sin(angle));
    return pointOnCircle * sqrt(RandomFloat(seed)); // Spread out points outside the center
}

vec3 GetEnvironmentColour(Ray ray) {
    float skyGradient = ray.direction.y + 1;
    return mix(vec3(1.0), vec3(0.5, 0.7, 1.0), skyGradient);
}

vec3 TraceRay(Ray ray, inout uint seed) {
    vec3 incomingLight = vec3(0.0);
    vec3 rayColour = vec3(1.0);

    for (int i = 0; i <= u_Bounces; i++) {
        HitInfo hitInfo = CalculateRayCollision(ray);
        if (hitInfo.didHit) {
            ray.origin = hitInfo.hitPoint + hitInfo.hitNormal * epsilon;

            Material material = hitInfo.hitMaterial;

            vec3 diffuseReflection = RandomHemisphereDirection(hitInfo.hitNormal, seed);
            vec3 specularReflection = reflect(ray.direction, hitInfo.hitNormal);
            ray.direction = mix(specularReflection, diffuseReflection, material.roughness);
            
            // If the source ray is not aligned with the normal, the incident ray is weaker
            // It's the Lambert Cosine
            float cosTheta = dot(hitInfo.hitNormal, ray.direction);
            vec3 emittedLight = material.emissionColour * material.emissionStrength;
            incomingLight += emittedLight * rayColour;
            rayColour *= material.colour * cosTheta * 2.0;
        } else {
            incomingLight += rayColour * GetEnvironmentColour(ray);
            break;
        }
    }

    return incomingLight;
}

void main() {
    ivec2 pixelCoords = ivec2(gl_GlobalInvocationID.xy);
    vec2 size = imageSize(newImgOutput);
    uint pixelIndex = uint(pixelCoords.y * size.x + pixelCoords.x);

    uint seed = pixelIndex + u_FrameIndex * 712314u;

    vec3 totalIncomingLight = vec3(0.0);

    // SSAA & focal
    for (int rayIndex = 0; rayIndex < u_NbRaysPerPixel; rayIndex++) {
        vec2 unitDisk = RandomPointInCircle(seed);
        vec2 jitter = unitDisk * u_DivergeStrength;

        vec2 uv = (vec2(pixelCoords) + jitter) / size * 2.0 - 1.0; // Normalize pixel coordinates between -1 & 1
        vec4 target = u_InverseProjection * vec4(uv, 1.0, 1.0); // Convert from screen coordinates to view coordinates
                                                                // This is the target without aperture.
                                                                // Need to recalculate the target if aperture

        Ray ray;
        ray.origin = u_CameraPosition;
        ray.direction = vec3(u_InverseView * vec4(normalize(vec3(target) / target.w), 0.0));

        if (u_Aperture > 0.0) {
            vec3 focusPoint = u_CameraPosition + ray.direction * u_FocusDistance;

            vec2 sensorOffset = unitDisk * u_Aperture / 10.0;
            vec3 worldOffset = (u_CameraRight * sensorOffset.x) + (u_CameraUp * sensorOffset.y);

            ray.origin = u_CameraPosition + worldOffset;
            ray.direction = normalize(focusPoint - ray.origin);
        }

        totalIncomingLight += TraceRay(ray, seed);
    }

    vec3 oldColour = imageLoad(oldImgOutput, pixelCoords).rgb;

    vec3 finalColour = (oldColour * (u_FrameIndex - 1) + totalIncomingLight / u_NbRaysPerPixel) / u_FrameIndex;

    imageStore(oldImgOutput, pixelCoords, vec4(finalColour, 1.0));

    // Reinhard Tone Mapping
    vec3 mapped = finalColour / (finalColour + vec3(1.0));
    imageStore(newImgOutput, pixelCoords, vec4(mapped, 1.0));
}